# -*- coding: utf8 -*-

import json, string

fproto = open('proto.txt', 'r')
fptdata = open('proto_data.txt', 'r')
frecv = open('../module/proto_recv.go', 'w')
fsend = open('../module/proto_send.go', 'w')
fsendc = open('../module/proto_send_c.go', 'w')
frdef = open('../module/proto_def.go', 'w')
frdefmap = open('../module/proto_map.go', 'w')
fpool = open('../module/proto_pool.go', 'w')

# 下面是客户端的文件
fcdef = open('../../../client/Assets/Script/Net/NetDef.cs', 'w')
fcrecv = open('../../../client/Assets/Script/Net/NetRecv.cs', 'w')
fcsend = open('../../../client/Assets/Script/Net/NetSend.cs', 'w')

arrAllProto = []    # 全部协议数据列表
arrProtoAsk = []    # 发送给服务端的请求
arrProtoRsp = []    # 返回客户端的协议
arrProtoLogin = []    # 登录的请求
arrProtoRegister = []    # 注册的请求
arrProtoMap = []    # 发送给地图的消息
dictArg = {}        # 全部数据集合
dictArgSort = {}    # 数据参数的排位,key是参数 协议数据从1开始，自定义数据从0开始
dictArgISort = {}    # 数据参数的排位,key是12345.. 协议数据从1开始，自定义数据从0开始
dictProtoID = {}    # 协议对应的id

frdef.write(
'''///////////////////////////////////////////////////////////////////////////
///////// This file is generated by proto/gen_proto.py from ///////////////
///////// proto.txt and proto_data.txt, do not edit!!!		///////////////
///////////////////////////////////////////////////////////////////////////
package module

''')

frdefmap.write(
'''///////////////////////////////////////////////////////////////////////////
///////// This file is generated by proto/gen_proto.py from ///////////////
///////// proto.txt and proto_data.txt, do not edit!!!		///////////////
///////////////////////////////////////////////////////////////////////////
package module

''')

fsend.write(
'''///////////////////////////////////////////////////////////////////////////
///////// This file is generated by proto/gen_proto.py from ///////////////
///////// proto.txt and proto_data.txt, do not edit!!!		///////////////
///////////////////////////////////////////////////////////////////////////
package module
import (
	"fmt"
	"github.com/vmihailenco/msgpack"
)

''')

fsendc.write(
'''///////////////////////////////////////////////////////////////////////////
///////// This file is generated by proto/gen_proto.py from ///////////////
///////// proto.txt and proto_data.txt, do not edit!!!		///////////////
///////////////////////////////////////////////////////////////////////////
package module
import (
    "net"
	"fmt"
	"github.com/vmihailenco/msgpack"
)

''')

frecv.write(
'''///////////////////////////////////////////////////////////////////////////
///////// This file is generated by proto/gen_proto.py from ///////////////
///////// proto.txt and proto_data.txt, do not edit!!!		///////////////
///////////////////////////////////////////////////////////////////////////
package module
import (
	"fmt"
	"github.com/vmihailenco/msgpack"
)

func decodeInt(n interface{}) int {
	switch n.(type) {
        case int:
            return n.(int)
		case int8:
			return int(n.(int8))
		case int16:
			return int(n.(int16))
		case int32:
			return int(n.(int32))
		case int64:
			return int(n.(int64))
		case uint8:
			return int(n.(int8))
		case uint16:
			return int(n.(uint16))
		case uint32:
			return int(n.(uint32))
		case uint64:
			return int(n.(uint64))
		default:
			return 0
	}
}

func Recv(pConnState *ConnState, buf []byte, data []interface{}) {
	defer func() {
		if x := recover(); x != nil {
			fmt.Println("Error from Recv: ", x)
		}
	}()
	err := msgpack.Unmarshal(buf, &data)
	if err != nil {
		fmt.Println("Error msgpack unpack:", err.Error())
		return
	}
	iProto := decodeInt(data[0])
	// fmt.Println("Receive msg: ", data)
	switch iProto {
''')

fpool.write(
'''///////////////////////////////////////////////////////////////////////////
///////// This file is generated by proto/gen_proto.py from ///////////////
///////// proto.txt and proto_data.txt, do not edit!!!		///////////////
///////////////////////////////////////////////////////////////////////////
package module

import(
	"sync"
)

''')

########## 客户端的文件 #############
fcdef.write(
'''///////////////////////////////////////////////////////////////////////////
///////// This file is generated by proto/gen_proto.py from ///////////////
///////// proto.txt and proto_data.txt, do not edit!!!		///////////////
///////////////////////////////////////////////////////////////////////////
using UnityEngine;
using System.Collections.Generic;

static class PROTO_ID
{
''')

fcrecv.write(
'''///////////////////////////////////////////////////////////////////////////
///////// This file is generated by proto/gen_proto.py from ///////////////
///////// proto.txt and proto_data.txt, do not edit!!!		///////////////
///////////////////////////////////////////////////////////////////////////
using UnityEngine;
using System;
using System.Collections.Generic;
using MsgPack;

public class NetRecv
{
    private static NetRecv instance_ = null;

    public static NetRecv Instance
    {
        get
        {
            if (instance_ == null)
                instance_ = new NetRecv();
            return instance_;
        }
    }

    public void Recv(List<MessagePackObject> recvObject)
    {
        if (recvObject.Count < 1)
        {
            Debug.Log("Why the recv object lenght less than 1?");
            return;
        }
        int proto = recvObject[0].AsInt32();
        switch (proto)
        {

''')

fcsend.write(
'''///////////////////////////////////////////////////////////////////////////
///////// This file is generated by proto/gen_proto.py from ///////////////
///////// proto.txt and proto_data.txt, do not edit!!!		///////////////
///////////////////////////////////////////////////////////////////////////
using UnityEngine;
using System.Collections.Generic;
using System.IO;
using MsgPack.Serialization;

public class NetSend
{
    private static NetSend instance_ = null;

    private MessagePackSerializer<List<object>> serializer_ = MessagePackSerializer.Get<List<object>>();
    private List<object> targetObject_ = new List<object>();
    private MemoryStream stream_ = new MemoryStream();

    public static NetSend Instance
    {
        get
        {
            if (instance_ == null)
                instance_ = new NetSend();
            return instance_;
        }
    }

    private void PackSend()
    {
        serializer_.Pack(stream_, targetObject_);

        NetClient.Instance.Send(stream_.ToArray());
        stream_.Flush();
        stream_.Position = 0;
        stream_.SetLength(0);
    }

''')
########## 客户端的文件 #############

ok = 1

#######################################################################
# 解析自定义数据
#######################################################################
arrOwnDataDef = [] # 自定义数据定义
arrCOwnDataDef = [] # 自定义数据定义(客户端)
line = fptdata.readline()
while line:
    if len(line) < 0:
        line = fptdata.readline()
        continue

    line = line.strip()

    if line[0] == '#':
        line = fptdata.readline()
        continue

    if line[0] != '{' or line[-1] != '}':
        print(line)
        print(u'格式错误，请以{}包裹!!!')
        ok = 0
        break

    line = line[1:-1]
    data = line.split(',')

    objName = data[0].strip()

    argList = data[1:]

    arrOwnDataDef.append('type %s struct {\n' % objName)
    arrCOwnDataDef.append('public class %s\n{\n' % objName)
    dictArg[objName] = {}
    dictArgSort[objName] = {}
    dictArgISort[objName] = {}
    # 遍历参数
    iSort = 0
    for arg in argList:
        arg.strip()
        if arg[0] != '{' and arg[-1] != '}' and arg[0] != '[' and arg[-1] != ']':
            print(arg)
            print(u'请填写正确的参数格式,{参数名:类型名},或者数组[{参数名:类型名}]!!!')
            ok = 0
            break

        if (arg[0] == '{' and arg[-1] == ']') or (arg[0] == '[' and arg[-1] == '}'):
            print(arg)
            print(u'请填写正确的参数格式,{参数名:类型名},或者数组[{参数名:类型名}]!!!')
            ok = 0
            break

        if arg[0] == '{' and arg[-1] == '}':
            arginfo = arg[1:-1].split(":")
            if len(arginfo) != 2:
                print(arg)
                print(u'请填写正确的参数格式,{参数名:类型名},或者数组[{参数名:类型名}]!!!')
                ok = 0
                break
            argname = arginfo[0].strip()
            argtype = arginfo[1].strip()
            arrOwnDataDef.append('\t%s %s\n' % (argname, argtype))
            arrCOwnDataDef.append('\tpublic %s %s;\n' % (argtype, argname))

        # 数组
        if arg[0] == '[' and arg[-1] == ']':
            if arg[1] != '{' or arg[-2] != '}':
                print(arg)
                print(u'请填写正确的参数格式,{参数名:类型名},或者数组[{参数名:类型名}]!!!')
                ok = 0
                break
            arginfo = arg[2:-2].split(":")
            if len(arginfo) != 2:
                print(arg)
                print(u'请填写正确的参数格式,{参数名:类型名},或者数组[{参数名:类型名}]!!!')
                ok = 0
                break
            argname = arginfo[0].strip()
            argtype = arginfo[1].strip()
            arrOwnDataDef.append('\t%s []%s\n' % (argname, argtype))
            arrCOwnDataDef.append('\tpublic List<%s> %s\n' % (argtype, argname) )

        dictArg[objName][argname] = argtype
        dictArgSort[objName][argname] = iSort
        dictArgISort[objName][iSort] = argname
        iSort += 1

    arrOwnDataDef.append('}\n\n')
    arrCOwnDataDef.append('}\n\n')
    line = fptdata.readline()

#######################################################################
# 解析协议
#######################################################################
arrDataDef = [] # 协议数据定义
arrDataMapDef = [] # 发送给地图的数据
arrCDataDef = [] # 协议数据定义 客户端的
arrnum = []
arrnumc = [] # 客户端的
number = 10001
line = fproto.readline()
while line:
    if len(line) < 0:
        line = fproto.readline()
        continue

    line = line.strip()

    if line == "":
        line = fproto.readline()
        continue

    if line[0] == '#':
        line = fproto.readline()
        continue

    if line[0] != '{' or line[-1] != '}':
        print(line)
        print(u'格式错误，请以{}包裹!!!')
        ok = 0
        break

    line = line[1:-1]
    data = line.split(',')
    
    objName = data[0].strip()
    cFrom = data[1].strip()
    cTo = data[2].strip()

    if (cFrom != 'server' and cFrom != 'client') or (cTo != 'server' and cTo != 'client' and cTo != 'login' and cTo != 'register' and cTo != 'map'):
        print(line)
        print(u'请填写正确的client和server或map!!!')
        ok = 0
        break

    if cTo == 'server' or cTo == 'login' or cTo == 'register' or cTo == 'map':
        arrProtoAsk.append(objName)
    else:
        arrProtoRsp.append(objName)
    
    if cTo == 'login':
        arrProtoLogin.append(objName)
    
    if cTo == 'register':
        arrProtoRegister.append(objName)
    
    if cTo == 'map':
        arrProtoMap.append(objName)

    argList = data[3:]
    
    arrDataDef.append('type %s struct {\n' % objName)
    arrCDataDef.append('public class %s\n{\n' % objName)

    if objName in arrProtoMap:
        arrDataMapDef.append('type Map%s struct {\n' % objName)
        arrDataMapDef.append('\tUserid int\n')
    
    arrAllProto.append(objName)
    dictArg[objName] = {}
    dictArgSort[objName] = {}
    dictArgISort[objName] = {}
    dictProtoID[objName] = string.upper(objName)
    iSort = 1
    
    # 遍历参数
    iarg = 0
    for arg in argList:
        arg.strip()
        if arg[0] != '{' and arg[-1] != '}' and arg[0] != '[' and arg[-1] != ']':
            print(arg)
            print(u'请填写正确的参数格式,{参数名:类型名},或者数组[{参数名:类型名}]!!!')
            ok = 0
            break

        if (arg[0] == '{' and arg[-1] == ']') or (arg[0] == '[' and arg[-1] == '}'):
            print(arg)
            print(u'请填写正确的参数格式,{参数名:类型名},或者数组[{参数名:类型名}]!!!')
            ok = 0
            break

        if arg[0] == '{' and arg[-1] == '}':
            arginfo = arg[1:-1].split(":")
            if len(arginfo) != 2:
                print(arg)
                print(u'请填写正确的参数格式,{参数名:类型名},或者数组[{参数名:类型名}]!!!')
                ok = 0
                break
            argname = arginfo[0].strip()
            argtype = arginfo[1].strip()
            arrDataDef.append('\t%s %s\n' % (argname, argtype))
            arrCDataDef.append('\tpublic %s %s;\n' % (argtype, argname))
            if objName in arrProtoMap:
                arrDataMapDef.append('\t%s %s\n' % (argname, argtype))
            isArr = False

        # 数组
        if arg[0] == '[' and arg[-1] == ']':
            if arg[1] != '{' or arg[-2] != '}':
                print(arg)
                print(u'请填写正确的参数格式,{参数名:类型名},或者数组[{参数名:类型名}]!!!')
                ok = 0
                break
            arginfo = arg[2:-2].split(":")
            if len(arginfo) != 2:
                print(arg)
                print(u'请填写正确的参数格式,{参数名:类型名},或者数组[{参数名:类型名}]!!!')
                ok = 0
                break
            argname = arginfo[0].strip()
            argtype = arginfo[1].strip()
            arrDataDef.append('\t%s []%s\n' % (argname, argtype))
            arrCDataDef.append('\tpublic List<%s> %s;\n' % (argtype, argname))
            if objName in arrProtoMap:
                arrDataMapDef.append('\t%s []%s\n' % (argname, argtype))
            isArr = True
        iarg += 1
        if isArr:
            dictArg[objName][argname] = '*' + argtype
        else:
            dictArg[objName][argname] = argtype
        dictArgSort[objName][argname] = iSort
        dictArgISort[objName][iSort] = argname
        iSort += 1

    arrDataDef.append('}\n')
    arrCDataDef.append('}\n\n')
    if objName in arrProtoMap:
        arrDataMapDef.append('}\n')

    if objName in arrProtoAsk and not objName in arrProtoLogin and not objName in arrProtoRegister and not objName in arrProtoMap:
        arrDataDef.append('// 请在相应模块实现%s的处理函数\n' % objName)
        arrDataDef.append('// func (self *%s) HandleMsg(pState *UserState) { }\n\n' % objName)
    elif objName in arrProtoMap:
        arrDataMapDef.append('// 请在相应模块实现Map%s的处理函数\n' % objName)
        arrDataMapDef.append('// func (self *Map%s) HandleMsg(pState *MapState) { }\n\n' % objName)
    else:
        arrDataDef.append('\n')

    if objName in arrProtoMap:
        arrDataMapDef.append('func (self *%s) HandleMsg(pUserState *UserState) {\n' % objName)
        arrDataMapDef.append('\tif chMap, ok := MpMapCh[pUserState.User.Mapid]; ok {\n')
        arrDataMapDef.append('\t\tvar ask = Map%sPool.Get().(Map%s)\n' % (objName, objName))
        arrDataMapDef.append('\t\task.Userid = pUserState.User.Userid\n')
        for i in range(1, len(dictArgISort[objName]) + 1):
            arrDataMapDef.append('\t\task.%s = self.%s\n' % (dictArgISort[objName][i], dictArgISort[objName][i]))
        arrDataMapDef.append('\t\tvar msg MapMsg = &ask\n')
        arrDataMapDef.append('\t\tchMap <- msg\n')
        arrDataMapDef.append('\t}\n}\n\n')
        


    arrnum.append('const %s = %d\n' % (string.upper(objName), number))
    arrnumc.append('\tpublic const int %s = %d;\n' % (string.upper(objName), number))
    number += 1
    
    line = fproto.readline()

#######################################################################
# 检测自定义数据结构是否包含自定义数据结构
#######################################################################
def hasMixData(datatype):
    h = False
    for argname in dictArg[datatype]:
        argtype = dictArg[datatype][argname]
        i = dictArgSort[datatype][argname]
        if argtype != 'int' and argtype != 'bool' and argtype != 'string':
            h = True
    return h

#######################################################################
# 生成解析代码 递归
#######################################################################
def parseCode(datatype, tab, deep):
    strCode = ''
    for argname in dictArg[datatype]:
        argtype = dictArg[datatype][argname]
        i = dictArgSort[datatype][argname]
        if argtype[0] == '*':
            argtype = argtype[1:]
            if argtype != 'int' and argtype != 'bool' and argtype != 'string':
                hasMix = hasMixData(datatype)
                objname = 'sl' + argname
                if deep == 0:
                    mixData = 'data'
                    key = 'key'
                    value = 'value'
                else:
                    mixData = 'mix' + str(deep)
                    key = 'key' + str(deep)
                    value = 'value' + str(deep)
                nextMixData = 'mix' + str(deep + 1)
                strCode += (tab + '%s := make([]%s, len(%s[%d].([]interface{})))\n' % (objname, argtype, mixData, i))
                strCode += (tab + 'for %s,%s := range %s[%d].([]interface{}) {\n' % (key, value, mixData, i))
                strCode += (tab + '\t%s := %s.([]interface{})\n' % (nextMixData, value))
                if hasMix:
                    strCode += parseCode(argtype, tab + '\t', deep + 1)
                strCode += (tab + '\t' + parseVarArg(argtype, 'item', nextMixData))
                strCode += (tab + '\t%s[%s] = item\n' % (objname, key))
                strCode += (tab + '}\n')
            else:
                hasMix = hasMixData(datatype)
                objname = 'sl' + argname
                if deep == 0:
                    mixData = 'data'
                    key = 'key'
                    value = 'value'
                else:
                    mixData = 'mix' + str(deep)
                    key = 'key' + str(deep)
                    value = 'value' + str(deep)
                nextMixData = 'mix' + str(deep + 1)
                strCode += (tab + '%s := make([]%s, len(%s[%d].([]interface{})))\n' % (objname, argtype, mixData, i))
                strCode += (tab + 'for %s, %s := range %s[%d].([]interface{}) {\n' % (key, value, mixData, i))
                strCode += (tab + '\t%s := %s.(%s)\n' % (nextMixData, value, argtype))
                strCode += (tab + '\t%s[%s] = %s\n' % (objname, key, nextMixData))
                strCode += (tab + '}\n')
        else:
            if argtype != 'int' and argtype != 'bool' and argtype != 'string':
                hasMix = hasMixData(datatype)
                objname = 'sl' + argname
                if deep == 0:
                    mixData = 'data'
                    key = 'key'
                    value = 'value'
                else:
                    mixData = 'mix' + str(deep)
                    key = 'key' + str(deep)
                    value = 'value' + str(deep)
                nextMixData = 'mix' + str(deep + 1)
                strCode += (tab + '%s := %s[%d].([]interface{})\n' % (objname, mixData, i))
                if hasMix:
                    strCode += parseCode(argtype, tab + '\t', deep + 1)
                strCode += (tab + parseVarArg(argtype, objname, nextMixData))

    return strCode


#######################################################################
# 生成解析代码 递归 客户端
#######################################################################    
def parseCodeClient(datatype, tab, deep, tag):
    strCode = ''
    for argname in dictArg[datatype]:
        argtype = dictArg[datatype][argname]
        i = dictArgSort[datatype][argname]
        if deep == 0:
            mixData = 'recvObject'
            mixDataLs = 'recvObject'
            objdataname = 'o' + datatype
        else:
            mixData = 'mix' + str(deep)
            mixDataLs = 'lsMix' + str(deep)
            objdataname = 'o' + tag + datatype
        nextMixData = 'mix' + str(deep + 1)
        nextMixDataLs = 'lsMix' + str(deep + 1)
        
        if argtype[0] == '*':
            argtype = argtype[1:]
            objtypename = 'o' + tag + argtype
            if argtype == 'int':
                strCode += (tab + 'List<int> ls%s = new List<int>();\n' % objtypename)
                strCode += (tab + 'foreach (MessagePackObject %s in %s[%d].AsList())\n' % (nextMixData, mixDataLs, i))
                strCode += (tab + '{\n')
                strCode += (tab + '\tls%s.Add(%s.AsInt32());\n' % (objtypename, nextMixData))
                strCode += (tab + '}\n')
                strCode += (tab + '%s.%s = ls%s;\n' % (objdataname, argname, objtypename))
            elif argtype == 'bool':
                strCode += (tab + 'List<bool> ls%s = new List<bool>();\n' % objtypename)
                strCode += (tab + 'foreach (MessagePackObject %s in %s[%d].AsList())\n' % (nextMixData, mixDataLs, i))
                strCode += (tab + '{\n')
                strCode += (tab + '\tls%s.Add(%s.AsBoolean());\n' % (objtypename, nextMixData))
                strCode += (tab + '}\n')
                strCode += (tab + '%s.%s = ls%s;\n' % (objdataname, argname, objtypename))
            elif argtype == 'string':
                strCode += (tab + 'List<string> ls%s = new List<string>();\n' % objtypename)
                strCode += (tab + 'foreach (MessagePackObject %s in %s[%d].AsList())\n' % (nextMixData, mixDataLs, i))
                strCode += (tab + '{\n')
                strCode += (tab + '\tls%s.Add(%s.AsString());\n' % (objtypename, nextMixData))
                strCode += (tab + '}\n')
                strCode += (tab + '%s.%s = ls%s;\n' % (objdataname, argname, objtypename))
            else:
                strCode += (tab + 'List<%s> ls%s = new List<%s>();\n' % (argtype, objtypename, argtype))
                strCode += (tab + 'foreach (MessagePackObject %s in %s[%d].AsList())\n' % (nextMixData, mixDataLs, i))
                strCode += (tab + '{\n')
                strCode += (tab + '\tIList<MessagePackObject> %s = %s.AsList();\n' %(nextMixDataLs, nextMixData))
                strCode += (tab + '\t%s %s = new %s();\n' % (argtype, objtypename, argtype))
                strCode += parseCodeClient(argtype, tab + '\t', deep + 1, tag)
                strCode += (tab + '\tls%s.Add(%s);\n' % (objtypename, objtypename))
                strCode += (tab + '}\n')
                strCode += (tab + '%s.%s = ls%s;\n' % (objdataname, argname, objtypename))
        else:
            objargname = 'o' + tag + argtype
            if argtype == 'int':
                strCode += (tab + '%s.%s = %s[%d].AsInt32();\n' % (objdataname, argname, mixDataLs, i))
            elif argtype == 'bool':
                strCode += (tab + '%s.%s = %s[%d].AsBoolean();\n' % (objdataname, argname, mixDataLs, i))
            elif argtype == 'string':
                strCode += (tab + '%s.%s = %s[%d].AsString();\n' % (objdataname, argname, mixDataLs, i))
            else:
                strCode += (tab + '%s %s = new %s();\n' % (argtype, objargname, argtype))
                strCode += (tab + 'foreach (MessagePackObject %s in %s[%d].AsList())\n' % (nextMixData, mixDataLs, i))
                strCode += (tab + '{\n')
                strCode += (tab + '\tIList<MessagePackObject> %s = %s.AsList();\n' %(nextMixDataLs, nextMixData))
                strCode += parseCodeClient(argtype, tab + '\t', deep + 1, tag)
                strCode += (tab + '}\n')
                strCode += (tab + '%s.%s = %s;\n' %(objdataname, argname, objargname))
    return strCode


#######################################################################
# struct定义赋值代码，var是变量名
#######################################################################
def parseVarArg(datatype, var, mixdata):
    arrDataStr = []
    for argname in dictArg[datatype]:
        argtype = dictArg[datatype][argname]
        i = dictArgSort[datatype][argname]
        if argtype == 'int':
            arrDataStr.append('%s: decodeInt(%s[%d])' % (argname,mixdata,i))
        elif argtype == 'string' or argtype == 'bool':
            arrDataStr.append('%s: %s[%d].(%s)' % (argname,mixdata,i,argtype))
        else:
            arrDataStr.append('%s: %s' % (argname,'sl'+argname))
    strDef = ', '.join(arrDataStr)
    strDef = ('var %s = %s{' % (var, datatype)) + strDef +'}\n'
    return strDef

#######################################################################
# struct变量赋值代码，var是变量名
#######################################################################
def parseVarAssign(datatype, mixdata):
    strDef = ''
    for argname in dictArg[datatype]:
        argtype = dictArg[datatype][argname]
        i = dictArgSort[datatype][argname]
        if argtype == 'int':
            strDef += '\t\t\task.%s = decodeInt(%s[%d])\n' % (argname,mixdata,i)
        elif argtype == 'string' or argtype == 'bool':
            strDef += '\t\t\task.%s = %s[%d].(%s)\n' % (argname,mixdata,i,argtype)
        else:
            strDef += '\t\t\task.%s = %s\n' % (argname,'sl'+argname)
    return strDef


#######################################################################
# 生成对象池处理代码
#######################################################################
def genPoolCode():
    for proto in arrProtoAsk:
        fpool.write('var %sPool *sync.Pool\n' % proto)
    
    for proto in arrProtoMap:
        fpool.write('var Map%sPool *sync.Pool\n' % proto)

    fpool.write('\nfunc InitProtoPool() {\n')
    for proto in arrProtoAsk:
        fpool.write('\t%sPool = &sync.Pool{\n' % proto)
        fpool.write('\t\tNew: func() interface{} {\n')
        fpool.write('\t\t\treturn %s{}\n' % proto)
        fpool.write('\t\t},\n\t}\n\n')

    for proto in arrProtoMap:
        fpool.write('\tMap%sPool = &sync.Pool{\n' % proto)
        fpool.write('\t\tNew: func() interface{} {\n')
        fpool.write('\t\t\treturn Map%s{}\n' % proto)
        fpool.write('\t\t},\n\t}\n\n')

    fpool.write('}\n\n')
    for proto in arrProtoAsk:
        fpool.write('func (self *%s) Release() {\n' % proto)
        fpool.write('\t%sPool.Put(*self)\n}\n\n' % proto)

    for proto in arrProtoMap:
        fpool.write('func (self *Map%s) Release() {\n' % proto)
        fpool.write('\tMap%sPool.Put(*self)\n}\n\n' % proto)

#######################################################################
# 生成模拟客户端测试发送的代码
#######################################################################
def genSendCCode(datatype):
    strSend = ''
    strSend += 'func Send%s(conn net.Conn%s) {\n' % (datatype, genSendFuncArg(datatype))
    strSend += '\tmsg := []interface{}{%s%s}\n' % (string.upper(datatype), genSendMsgArg(datatype))
    strSend += '\tbuf, err := msgpack.Marshal(msg)\n'
    strSend += '\tif err != nil {\n'
    strSend += '\t\tfmt.Println("Error in Send%s: ", err.Error())\n' % datatype
    strSend += '\t} else {\n'
    strSend += '\t\tconn.Write(buf)\n'
    strSend += '\t}\n}\n\n'
    return strSend

#######################################################################
# 生成真实客户端发送的代码
#######################################################################
def genSendCodeClient(datatype):
    strSend = ''
    strSend += '\tpublic void Send%s(%s)\n\t{\n' % (datatype, genSendFuncArgClient(datatype))
    strSend += '\t\ttargetObject_.Clear();\n\n'
    strSend += '\t\ttargetObject_.Add(PROTO_ID.%s);\n' % string.upper(datatype)
    strSend += genSendFuncValueClient(datatype)
    strSend += '\t\tPackSend();\n'
    strSend += '\t}\n\n'
    return strSend

#######################################################################
# 生成发送代码
#######################################################################
def genSendCode(datatype):
    strSend = ''
    strSend += 'func Send%s(chSender chan []byte%s) {\n' % (datatype, genSendFuncArg(datatype))
    strSend += '\tmsg := []interface{}{%s%s}\n' % (string.upper(datatype), genSendMsgArg(datatype))
    strSend += '\tbuf, err := msgpack.Marshal(msg)\n'
    strSend += '\tif err != nil {\n'
    strSend += '\t\tfmt.Println("Error in Send%s: ", err.Error())\n' % datatype
    strSend += '\t} else {\n'
    strSend += '\t\tchSender <- buf\n'
    strSend += '\t}\n}\n\n'

    strSend += 'func Bro%s(pState *MapState%s) {\n' % (datatype, genSendFuncArg(datatype))
    strSend += '\tmsg := []interface{}{%s%s}\n' % (string.upper(datatype), genSendMsgArg(datatype))
    strSend += '\tbuf, err := msgpack.Marshal(msg)\n'
    strSend += '\tif err != nil {\n'
    strSend += '\t\tfmt.Println("Error in Send%s: ", err.Error())\n' % datatype
    strSend += '\t} else {\n'
    strSend += '\t\tfor _, userInfo := range pState.MpUserInfo {\n'
    strSend += '\t\t\tuserInfo.ChSender <- buf\n'
    strSend += '\t\t}\n\t}\n}\n\n'

    return strSend


#######################################################################
# 生成接收代码
#######################################################################
def genRecvCode(datatype):
    strRecv = ''
    strRecv += '\t\tcase %s:\n' % dictProtoID[datatype]
    strRecv += parseCode(datatype, '\t\t\t', 0)
    if datatype in arrProtoLogin:
        strRecv += '\t\t\t' + parseVarArg(datatype, 'ask', 'data')
        strRecv += '\t\t\tUserLogin(pConnState, ask)\n'
    elif datatype in arrProtoRegister:
        strRecv += '\t\t\t' + parseVarArg(datatype, 'ask', 'data')
        strRecv += '\t\t\tUserRegister(pConnState, ask)\n'
    else:
        strRecv += '\t\t\tvar ask = %sPool.Get().(%s)\n' % (datatype, datatype)
        # strRecv += '\t\t\t' + parseVarArg(datatype, 'ask UserMsg', 'data')
        strRecv += parseVarAssign(datatype, 'data')
        strRecv += '\t\t\tvar msg UserMsg = &ask\n'
        strRecv += '\t\t\tif pConnState.UserInfo.ChUser != nil {\n'
        strRecv += '\t\t\t\tpConnState.UserInfo.ChUser <- msg\n'
        strRecv += '\t\t\t} else {\n'
        strRecv += '\t\t\t\tSendLoginRsp(pConnState.ChSender, false, 0)\n\t\t\t}\n'
    return strRecv

#######################################################################
# 生成接收代码 客户端的
#######################################################################
def genRecvCodeClient(datatype):
    strRecv = ''
    strRecv += '\t\t\tcase PROTO_ID.%s:\n' % dictProtoID[datatype]
    strRecv += '\t\t\t\t%s o%s = new %s();\n' % (datatype, datatype, datatype)
    strRecv += parseCodeClient(datatype, '\t\t\t\t', 0, datatype)
    strRecv += '\t\t\t\tNetCallBack.Instance.%s(o%s);\n' % (datatype, datatype)
    strRecv += '\t\t\t\tbreak;\n'
    return strRecv

#######################################################################
# 生成发送函数参数
#######################################################################
def genSendFuncArg(datatype):
    strArg = ''
    for i in range(0, len(dictArg[datatype])):
        argname = dictArgISort[datatype][i+1]
        argtype = dictArg[datatype][argname]
        if argtype == 'int' or argtype == 'string' or argtype == 'bool':
            strArg += (', ' + argname + ' ' + argtype)
        else:
            strArg += (', ' + argname + ' []interface{}')
    return strArg

#######################################################################
# 生成发送函数参数 客户端的
#######################################################################
def genSendFuncArgClient(datatype):
    arrArg = []
    for i in range(0, len(dictArg[datatype])):
        argname = dictArgISort[datatype][i+1]
        argtype = dictArg[datatype][argname]
        if argtype == 'int' or argtype == 'string' or argtype == 'bool':
            arrArg.append(argtype + ' ' + argname)
        else:
            arrArg.append('List<object> ' + argname)
    strArg = ', '.join(arrArg)
    return strArg

#######################################################################
# 生成发送函数赋值的代码 客户端的
#######################################################################
def genSendFuncValueClient(datatype):
    strArg = ''
    for i in range(0, len(dictArg[datatype])):
        argname = dictArgISort[datatype][i+1]
        strArg += '\t\ttargetObject_.Add(%s);\n' % argname
    return strArg

#######################################################################
# 生成发送赋值参数
#######################################################################
def genSendMsgArg(datatype):
    strArg = ''
    for i in range(0, len(dictArg[datatype])):
        argname = dictArgISort[datatype][i+1]
        strArg += (', ' + argname)
    return strArg

if ok:
    ##################### 服务端的 #########################
    frdef.writelines(arrnum)
    frdef.write('\n')
    frdef.writelines(arrOwnDataDef)
    frdef.writelines(arrDataDef)

    frdefmap.writelines(arrDataMapDef)

    for protoAsk in arrProtoAsk:
        frecv.write(genRecvCode(protoAsk))   
    frecv.write('\t\tdefault:\n')
    frecv.write('\t\t\tfmt.Println("Error proto id: ", iProto, " and msg data: ", data)\n')
    frecv.write('\t}\n')
    frecv.write('}\n')

    for proto in arrProtoRsp:
        fsend.write(genSendCode(proto))

    genPoolCode()

    for proto in arrProtoAsk:
        fsendc.write(genSendCCode(proto))
    
   
    ##################### 服务端的 #########################

    ##################### 客户端的 #########################
    fcdef.writelines(arrnumc)
    fcdef.write('}\n\n')
    fcdef.writelines(arrCOwnDataDef)
    fcdef.writelines(arrCDataDef)

    for proto in arrProtoAsk:
        fcsend.write(genSendCodeClient(proto))
    fcsend.write('}')

    for proto in arrProtoRsp:
        fcrecv.write(genRecvCodeClient(proto))
    fcrecv.write('\t\t\tdefault:\n')
    fcrecv.write('\t\t\t\tDebug.Log("Unknow proto id: " + proto);\n')
    fcrecv.write('\t\t\t\tbreak;\n')
    fcrecv.write('\t\t}\n\t}\n}')
    ##################### 客户端的 #########################

fproto.close()
frecv.close()
fsend.close()
fsendc.close()
fptdata.close()
frdef.close()
fcdef.close()
fcrecv.close()
fcsend.close()
